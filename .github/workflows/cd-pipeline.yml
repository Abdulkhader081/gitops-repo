name: GitOps CD Pipeline - ArgoCD Sync

on:
  push:
    branches: [ main ]
    tags: [ 'v*' ]  # Triggers on version tags like v1.0.0, v1.2.3, etc.
  workflow_dispatch:  # Allow manual triggering
    inputs:
      tag:
        description: 'Tag to sync (e.g., v1.0.0)'
        required: true
        default: 'latest'

env:
  ARGOCD_SERVER: argocd.local
  ARGOCD_NAMESPACE: argocd
  APP_NAME: flask-app-production

jobs:
  argocd-sync:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    
    steps:
    - name: Checkout current repo (with tags)
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        ref: ${{ github.ref }}
    
    - name: Extract tag version
      id: extract_tag
      run: |
        # Get the tag that triggered the workflow
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          echo "TAG_VERSION=${{ github.event.inputs.tag }}" >> $GITHUB_OUTPUT
        else
          echo "TAG_VERSION=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT
        fi
        echo "Extracted tag: $TAG_VERSION"
    
    - name: Set up Kubernetes context
      uses: azure/setup-kubectl@v3
      with:
        version: 'latest'
    
    - name: Install ArgoCD CLI
      run: |
        curl -sSL -o argocd-linux-amd64 https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
        sudo install -m 555 argocd-linux-amd64 /usr/local/bin/argocd
        rm argocd-linux-amd64
        argocd version --client
    
    - name: Configure Kubernetes context
      run: |
        # Set up kubeconfig (update with your cluster configuration)
        mkdir -p ~/.kube
        echo '${{ secrets.KUBECONFIG }}' > ~/.kube/config
        kubectl config use-context ${{ secrets.CLUSTER_CONTEXT }}
        
        # Verify connection
        kubectl cluster-info
        kubectl get nodes
    
    - name: Login to ArgoCD
      run: |
        # Get ArgoCD admin password
        ARGOCD_PASSWORD=$(kubectl -n $ARGOCD_NAMESPACE get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d)
        
        # Login to ArgoCD
        argocd login $ARGOCD_SERVER --username admin --password $ARGOCD_PASSWORD --insecure
        
        # Verify login
        argocd app list
    
    - name: Update GitOps repository with new tag
      env:
        GITOPS_REPO: ${{ secrets.GITOPS_REPO }}
        GITOPS_SSH_KEY: ${{ secrets.GITOPS_SSH_KEY }}
      run: |
        TAG_VERSION=${{ steps.extract_tag.outputs.TAG_VERSION }}
        
        # Configure git with deploy key
        mkdir -p ~/.ssh
        echo "$GITOPS_SSH_KEY" > ~/.ssh/gitops_key
        chmod 600 ~/.ssh/gitops_key
        echo -e "Host github.com\n  IdentityFile ~/.ssh/gitops_key\n  IdentitiesOnly yes" > ~/.ssh/config
        
        # Clone the GitOps repository
        git clone git@github.com:$GITOPS_REPO.git gitops-repo
        cd gitops-repo
        
        # Update image tag in production overlay
        cd overlays/production
        
        # Install yq if not present
        if ! command -v yq &> /dev/null; then
          sudo wget https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64 -O /usr/local/bin/yq
          sudo chmod +x /usr/local/bin/yq
        fi
        
        # Update the image tag
        yq eval ".images[0].newTag = \"$TAG_VERSION\"" -i kustomization.yaml
        
        # Display changes for verification
        echo "Updated kustomization.yaml:"
        cat kustomization.yaml
        
        # Commit and push changes
        git config user.name "github-actions"
        git config user.email "github-actions@github.com"
        git add kustomization.yaml
        git commit -m "CD: Update image tag to $TAG_VERSION"
        git push origin main
        
        echo "âœ… GitOps repository updated with new tag: $TAG_VERSION"
    
    - name: Sync ArgoCD application
      run: |
        TAG_VERSION=${{ steps.extract_tag.outputs.TAG_VERSION }}
        
        echo "Syncing ArgoCD application $APP_NAME with tag: $TAG_VERSION"
        
        # Sync the application
        argocd app sync $APP_NAME --prune
        
        # Wait for sync to complete
        argocd app wait $APP_NAME --healthy --timeout 300
        
        # Get application status
        echo "Application status:"
        argocd app get $APP_NAME
    
    - name: Verify deployment
      run: |
        echo "Verifying deployment in production namespace..."
        
        # Check deployment status
        kubectl -n production get deployments
        kubectl -n production get pods
        
        # Wait for pods to be ready
        kubectl -n production wait --for=condition=available deployment/flask-app --timeout=300s
        
        echo "Deployment verification completed successfully"
    
    - name: Send notification
      if: success()
      run: |
        echo "ðŸš€ Deployment successful! Tag ${{ steps.extract_tag.outputs.TAG_VERSION }} is now live in production"
        # Add notification integration here if desired

  manual-rollback:
    runs-on: ubuntu-latest
    needs: argocd-sync
    if: failure()
    
    steps:
    - name: Install ArgoCD CLI
      run: |
        curl -sSL -o argocd-linux-amd64 https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
        sudo install -m 555 argocd-linux-amd64 /usr/local/bin/argocd
    
    - name: Configure Kubernetes context
      run: |
        mkdir -p ~/.kube
        echo '${{ secrets.KUBECONFIG }}' > ~/.kube/config
        kubectl config use-context ${{ secrets.CLUSTER_CONTEXT }}
    
    - name: Rollback to previous version
      run: |
        # Login to ArgoCD
        ARGOCD_PASSWORD=$(kubectl -n $ARGOCD_NAMESPACE get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d)
        argocd login $ARGOCD_SERVER --username admin --password $ARGOCD_PASSWORD --insecure
        
        # Rollback to previous version
        argocd app rollback $APP_NAME
        
        echo "Rollback initiated due to deployment failure"
